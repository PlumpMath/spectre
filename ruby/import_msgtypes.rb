require 'optparse'

class MessageGenerator
    def initialize()
        @pkg_list = Array.new
        @msg_list = Array.new
    end

    def parse(fname)
        File.open(fname) do |io|
            io.each do |line|
                cls_name, cls_id, path = line.strip.split(%r{\s*:\s*})
                add_msg_type(cls_name, cls_id, path) unless cls_name.nil? || cls_id.nil? || path.nil?
            end
        end
    end

    def add_msg_type(cls_name, cls_id, path)
        pkg_fields = []
        pkg_fields << "aspect"
        # Determine if basic/derived aspect
        pkg_fields << path.split('/')[1]
        # Need to move CamelCase back to under_score (this is super brittle, assumed files are under_score)
        pkg_fields << cls_name.split(".")[0].split(/(?!(^|[a-z]|$))/).join('_').downcase + ".pb"
        pkg_name = pkg_fields.join('/')
        cls_name = cls_name.split(".").map { |e| e[0].capitalize + e[1..-1]  }.join("::")
        @pkg_list.push pkg_name unless @pkg_list.include? pkg_name
        @msg_list.push({ :cls_name => cls_name, :cls_id => cls_id, :path => path})
    end

    def save(fname)
        File.open(fname, 'w') do |io|
            io.write("# Auto-generated by import_msgtypes.rb\n# Do not edit\n\n")
            # Add the requires for each package
            @pkg_list.each do |pkg|
                io.write("require '#{pkg}'\n")
            end

            # Write the actual Mapper
            io.write("\nmodule AspectMapper\n\tMAPPER = {\n")
            @msg_list.each do |msg|
                io.write("\t\t'#{msg[:path]}' => { :cls => #{msg[:cls_name]}, :id => #{msg[:cls_id]} },\n")
            end
            io.write("\t}\nend")
        end
    end
end

options = {}
OptionParser.new do |opts|
    opts.banner = "Usage: import_msgtypes.rb [options]"

    opts.on("-i", "--input REQUIRED", "Path to msgtypes.properties") do |fname|
        options[:input] = fname
    end

    opts.on("-o", "--output REQUIRED", "Destination path to write the mapper.rb") do |fname|
        options[:output] = fname
    end

    opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
    end
end.parse!

raise OptionParser::MissingArgument, "-i/--input required" unless options.include? :input
raise OptionParser::MissingArgument, "-o/--output required" unless options.include? :output

gen = MessageGenerator.new
gen.parse options[:input]
gen.save options[:output]